<script>
    class MazeBuilder{

        constructor(){
            this.startxcoordwall = null;
            this.endxcoordwall = null;
            this.maze_matrix = []; //char
            this.coordinate_matrix = []; //bool
            this.directions = []; //string
            this.row_size = null;
            this.col_size = null;
            this.lastk = null;
            this.deadend = false;
            this.atend = false;
        }

        instantiateMaze(size){
            this.numOfCells = size;
            this.sizeOfMaze = (size*2)+1;
            this.constructMatricies();
            this.makeMaze(this.startxcoordwall,1);
        }

        solveMaze(){
            for(let i = 0; i < this.sizeOfMaze**2; i++){this.directions.push("");}
            this.solver(this.startxcoordwall,0,[true,false,false,false],0);
        }
        
        constructMatricies(){
            for(let i = 0; i < this.sizeOfMaze; i++){
                this.maze_matrix.push([]);
                this.coordinate_matrix.push([]);
                for(let j = 0; j < this.sizeOfMaze; j++){
                    this.coordinate_matrix[i].push(false);
                    if((i%2==0)||(i==0)){
                        this.maze_matrix[i].push('#');
                    }else if((j%2==0)||(j==0)){
                        this.maze_matrix[i].push('#');
                    }else{
                        this.maze_matrix[i].push(' ');
                    }
                }
            }
            this.startxcoordwall = this.randomOddNumberGeneratorForMazeBlock();
            this.endxcoordwall = this.randomOddNumberGeneratorForMazeBlock();
            this.maze_matrix[this.startxcoordwall][0] = ' ';
            this.maze_matrix[this.endxcoordwall][this.sizeOfMaze-1] = ' ';
            this.coordinate_matrix[this.startxcoordwall][1] = true;
        }
        
        //ret int
        randomOddNumberGeneratorForMazeBlock(){
            let returnInt = 0;
            let isOdd = false;
            while(!isOdd){
                returnInt = Math.floor(Math.random() * (this.sizeOfMaze-2));
                if(returnInt != 1){
                    isOdd = (returnInt%2 != 0);
                }else{
                    isOdd = true;
                }
            }
            return returnInt;
        }
        
        makeMaze(xcoor,ycoor){
            let nor = this.canGoNorth(xcoor,ycoor);
            let sou = this.canGoSouth(xcoor,ycoor);
            let eas = this.canGoEast(xcoor,ycoor);
            let wes = this.canGoWest(xcoor,ycoor);
        
            if(!nor && !sou && !eas && !wes){
                //break case
            }else{
                let hasMoved = false;
                while(!hasMoved){
                    let res = Math.floor(Math.random() * 4);
                    switch(res){
                        case 0:
                            if(nor){
                                this.coordinate_matrix[xcoor-2][ycoor] = true;
                                this.maze_matrix[xcoor-1][ycoor] = ' ';
                                hasMoved = true;
                                this.makeMaze(xcoor-2,ycoor);
                            }
                            break;
                        case 1:
                            if(sou){
                                this.coordinate_matrix[xcoor+2][ycoor] = true;
                                this.maze_matrix[xcoor+1][ycoor] = ' ';
                                hasMoved = true;
                                this.makeMaze(xcoor+2,ycoor);
                            }
                            break;
                        case 2:
                            if(eas){
                                this.coordinate_matrix[xcoor][ycoor+2] = true;
                                this.maze_matrix[xcoor][ycoor+1] = ' ';
                                hasMoved = true;
                                this.makeMaze(xcoor,ycoor+2);
                            }
                            break;
                        case 3:
                            if(wes){
                                this.coordinate_matrix[xcoor][ycoor-2] = true;
                                this.maze_matrix[xcoor][ycoor-1] = ' ';
                                hasMoved = true;
                                this.makeMaze(xcoor,ycoor-2);
                            }
                            break;
                    }
                }
                this.makeMaze(xcoor,ycoor);
            }
        }
        
        //int int
        //ret bool
        canGoNorth(xcoor,ycoor){
            let ret_bool = true;
            if(xcoor==1){
                ret_bool = false;
            }else if(this.coordinate_matrix[xcoor-2][ycoor] == true){
                ret_bool = false;
            }
            return ret_bool;
        }
        
        //int int
        //ret bool
        canGoSouth(xcoor,ycoor){
            let ret_bool = true;
            if(xcoor == (this.sizeOfMaze - 2)){
                ret_bool = false;
            }else if(this.coordinate_matrix[xcoor+2][ycoor] == true){
                ret_bool = false;
            }
            return ret_bool;
        }
        
        //int int
        //ret bool
        canGoEast(xcoor,ycoor){
            let ret_bool = true;
            if(ycoor == (this.sizeOfMaze - 2)){
                ret_bool = false;
            }else if(this.coordinate_matrix[xcoor][ycoor+2] == true){
                ret_bool = false;
            }
            return ret_bool;
        }
        
        //int int
        //bool
        canGoWest(xcoor,ycoor){
            let ret_bool = true;
            if(ycoor == 1){
                ret_bool = false;
            }else if(this.coordinate_matrix[xcoor][ycoor-2] == true){
                ret_bool = false;
            }
            return ret_bool;
        }
        
        updateMazeDOMElements(){
        
        }
        
        //int int bool bool bool bool int
        solver(x,y,fromBools,k){
        
            /*left top right bottom*/
            let wallBools = [
                this.isWall(x,y-1),
                this.isWall(x-1,y),
                this.isWall(x,y+1),
                this.isWall(x+1,y)
            ];
            let d = k+1;
            if(this.endChecker(x,y)){
                this.maze_matrix[x][y] = '~';
                this.directions[k] = "Right";
                this.atend = true;
                this.lastk = k;
            }else if(fromBools[0]){
                this.solver_helper(x,y,fromBools,wallBools,d,k);
            }else if(fromBools[1]){
                this.solver_helper(x,y,fromBools,wallBools,d,k);
            }else if(fromBools[2]){
                this.solver_helper(x,y,fromBools,wallBools,d,k);
            }else if(fromBools[3]){
                this.solver_helper(x,y,fromBools,wallBools,d,k);
            }
        }
        
        solver_helper(x,y,fromBools,wallBools,d,k){
            //left wall
            if(!fromBools[0]){
                if(!wallBools[0] && !this.atend){
                    this.maze_matrix[x][y] = '~';
                    this.directions[k] = "Left";
                    this.solver(x,y-1,[false,false,true,false],d);
                }
            }
            //top wall
            if(!fromBools[1]){
                if(!wallBools[1] && !this.atend){
                    this.maze_matrix[x][y] = '~';
                    this.directions[k] = "Up";
                    this.solver(x-1,y,[false,false,false,true],d);
                }
            }
            //right wall
            if(!fromBools[2]){
                if(!wallBools[2] && !this.atend){
                    this.maze_matrix[x][y] = '~';
                    this.directions[k] = "Right";
                    this.solver(x,y+1,[true,false,false,false],d);
                }
            }
            //bottom wall
            if(!fromBools[3]){
                if(!wallBools[3] && !this.atend){
                    this.maze_matrix[x][y] = '~';
                    this.directions[k] = "Down";
                    this.solver(x+1,y,[false,true,false,false],d);
                }
            }
            //at end
            if(!this.atend){
                this.maze_matrix[x][y] = ' ';
                this.directions[k] = "";
            }
        }
        
        //int int
        //ret bool
        isWall(x,y){
            if(this.maze_matrix[x][y] == '#'){
                return true;
            }else{
                return false;
            }
        }
        
        //int int
        //ret bool
        endChecker(x,y){
            if(x == this.endxcoordwall && y == this.sizeOfMaze-1){
                return true;
            }else{
                return false;
            }
        }
        
        printMaze(){
            let printString = "";
            for(let i = 0; i < this.sizeOfMaze; i++){
                for(let j = 0; j < this.sizeOfMaze; j++){
                    printString += this.maze_matrix[i][j];
                    printString += " ";
                }
                printString +="\n";
            }
            console.log(printString);
        }
        printDirections(){
            for(let i = 0; i < this.lastk; i++){
                console.log(this.directions[i]);
            }
        }
    };
</script>